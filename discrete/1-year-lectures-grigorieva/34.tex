\documentclass[discrete.tex]{subfiles}

\begin{document}
  \section{B-деревья}

  \begin{definition}
    B-деревом называется дерево, удовлетворяющее следующим свойствам:
    \begin{enumerate}
      \item Ключи в каждом узле обычно упорядочены для быстрого доступа к ним. Корень содержит от 1 до $2t-1$ ключей. Любой другой узел содержит от $t-1$ до $2t-1$ ключей. Листья не являются исключением из этого правила. Здесь $t$ — параметр дерева, не меньший 2 (и обычно принимающий значения от 50 до 2000).
      \item У листьев потомков нет. Любой другой узел, содержащий ключи $K_1, ..., K_n$, содержит $n+1$ потомков. При этом:
      \begin{enumerate}
        \item Первый потомок и все его потомки содержат ключи из интервала
        $(-\infty ,K_{1})$
        \item Для $2\leq i\leq n$, i-й потомок и все его потомки содержат ключи из интервала $(K_{i-1},K_i)$
        \item $(n+1)$-й потомок и все его потомки содержат ключи из интервала
        $(K_n,\infty )$
      \end{enumerate}
      \item Глубина всех листьев одинакова.
    \end{enumerate}

    Свойство 2 можно сформулировать иначе: каждый узел B-дерева, кроме листьев, можно рассматривать как упорядоченный список, в котором чередуются ключи и указатели на потомков.
  \end{definition}

  \begin{alg}[поиск ключа]
    Если ключ содержится в корне, он найден. Иначе определяем интервал и идём к соответствующему потомку. Повторяем.
  \end{alg}

  \begin{alg}[добавление ключа]
    Будем называть ''деревом потомков некоего узла'' поддерево, состоящее из этого узла и его потомков.

    Вначале определим функцию, которая добавляет ключ K к дереву потомков узла x. После выполнения функции во всех пройденных узлах, кроме, может быть, самого узла x, будет меньше $2t-1$, но не меньше $t-1$, ключей.
    \begin{enumerate}
      \item Если х — не лист,
      \begin{enumerate}
        \item Определяем интервал, где должен находиться K. Пусть y — соответствующий потомок.
        \item Рекурсивно добавляем K к дереву потомков y.
        \item Если узел y полон, то есть содержит $2t-1$ ключей, расщепляем его на два. Узел $y_1$ получает первые $t-1$ из ключей y и первые $t$ его потомков, а узел $y_2$ — последние $t-1$ из ключей y и последние $t$ его потомков. Медианный из ключей узла y попадает в узел х, а указатель на y в узле x заменяется указателями на узлы $y_1$ и $y_2$.
      \end{enumerate}
      \item Если x — лист, просто добавляем туда ключ K.

      Теперь определим добавление ключа K ко всему дереву. Буквой R обозначается корневой узел.
      \item Добавим K к дереву потомков R.
      \item Если R содержит теперь $2t-1$ ключей, расщепляем его на два. Узел $R_1$ получает первые $t-1$ из ключей R и первые $t$ его потомков, а узел $R_2$ — последние $t-1$ из ключей R и последние $t$ его потомков. Медианный из ключей узла R попадает вo вновь созданный узел, который становится корневым. Узлы $R_1$ и $R_2$ становятся его потомками.
    \end{enumerate}
  \end{alg}

  \begin{alg}[удаление ключа]
    Если корень одновременно является листом, то есть в дереве всего один узел, мы просто удаляем ключ из этого узла. В противном случае сначала находим узел, содержащий ключ, запоминая путь к нему. Пусть этот узел — $x$.

    Если $x$ — лист, удаляем оттуда ключ. Если в узле $x$ осталось не меньше $t-1$ ключей, мы на этом останавливаемся. Иначе мы смотрим на количество ключей в следующем, а потом в предыдущем узле. Если следующий узел есть, и в нём не менее $t$ ключей, мы добавляем в $x$ ключ-разделитель между ним и следующим узлом, а на его место ставим первый ключ следующего узла, после чего останавливаемся. Если это не так, но есть предыдущий узел, и в нём не менее $t$ ключей, мы добавляем в $x$ ключ-разделитель между ним и предыдущим узлом, а на его место ставим последний ключ предыдущего узла, после чего останавливаемся. Наконец, если и с предыдущим ключом не получилось, мы объединяем узел $x$ со следующим или предыдущим узлом, и в объединённый узел перемещаем ключ, разделяющий два узла. При этом в родительском узле может остаться только $t-2$ ключей. Тогда, если это не корень, мы выполняем аналогичную процедуру с ним. Если мы в результате дошли до корня, и в нём осталось от 1 до $t-1$ ключей, делать ничего не надо, потому что корень может иметь и меньше $t-1$ ключей. Если же в корне не осталось ни одного ключа, исключаем корневой узел, а его единственный потомок делаем новым корнем дерева.

    Если $x$ — не лист, а K — его $i$-й ключ, удаляем самый правый ключ из поддерева потомков $i$-го потомка $x$, или, наоборот, самый левый ключ из поддерева потомков $i+1$-го потомка $x$. После этого заменяем ключ K удалённым ключом. Удаление ключа происходит так, как описано в предыдущем абзаце.
  \end{alg}


\end{document}
