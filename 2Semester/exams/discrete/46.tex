\documentclass[discrete.tex]{subfiles}

\begin{document}

\begin{definition}[Алгоритм Левита]
    $M_0 $  - вершины,
    расстоние до которых уже вычислено, (но возможно не окончательно)\\
    $M_1$ - очередь вершин, расстояние до которых вычисляется\\
    $M_2$ - вершины, расстояние до которых еще не вычислено\\
    $d[i]$ - расстояние до $i$-ой вершины\\
    \\
    Изначально в $M_1$ лежит стартовая вершина, в $M_2$ все остальные.\\
    $M_0$ - пусто\\
    А d[i] = $+\infty$, кроме $d[start]$ = 0\\
    \\
    На каждом шаге берем вершину из $M_1$ (первый элемент в очереди). Пусть V - 
    это выбранная вершина. Переводим эту вершину в $M_0$. Просматриваем все ребра, 
    выходящие из $V$. Пусть $T$ - второй конец текущего ребра (то есть не равный $V$), 
    а $L$ - длины текущего ребра.\\

    Тогда
    \begin{enumerate}
        \item Если $T$ из $M_2$, то переводим ее в $M_1$ (в конец очереди).
            \[d[T] = d[V] + L\]
        \item Если $T$ из $M_1$, то пытаемся улучшить значение $d[T]$
            \[d[T] = \min(d[T], d[V] + L)\]
        \item Если $T$ из $M_0$, и если $d[T]$ можно улучшить, то улучшаем $d[T]$, а 
            вершину возвращаем в $M_1$
    \end{enumerate}
    В Романовском используется дополнительная "срочная" \  очередь $M_1''$, в которую
    возвращаются элементы из $M_0$ и на каждом шаге сначала берут вершину оттуда, а уже 
    потом из основной очереди. Вероятно, такой подход ускорит работу алгоритма.
\end{definition}

\end{document}
