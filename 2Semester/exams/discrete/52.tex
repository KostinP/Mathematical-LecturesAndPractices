\documentclass[discrete.tex]{subfiles}

\begin{document}
  \section{Задача о назначениях. Венгерский метод}

  \href{https://math.semestr.ru/nazn/venger.php}{первое что нашел}

  Дана неотрицательная матрица размера n×n, где элемент в i-й строке и j-м столбце соответствует стоимости выполнения j-го вида работ i-м работником. Нужно найти такое соответствие работ работникам, чтобы расходы на оплату труда были наименьшими. Если цель состоит в нахождении назначения с наибольшей стоимостью, то решение сводится к решению только что сформулированной задачи путём замены каждой стоимости C на разность между максимальной стоимостью и C

  Алгоритм основан на двух идеях:

  если из всех элементов некой строки или столбца вычесть одно и то же число {\displaystyle y}y, общая стоимость уменьшится на {\displaystyle y}y, а оптимальное решение не изменится;
  если есть решение нулевой стоимости, то оно оптимально.
  Алгоритм ищет значения, которые надо вычесть из всех элементов каждой строки и каждого столбца (разные для разных строк и столбцов), такие, что все элементы матрицы останутся неотрицательными, но появится нулевое решение.

  Алгоритм проще описать, если сформулировать задачу, используя [[двудольный граф]].
Дан [[полный двудольный граф]] ''G=(S, T; E)'' c ''n'' вершинами, соответствующими работникам (''S''), и ''n'' вершинами, соответствующими видам работ (''T''); стоимость каждого ребра ''c(i, j)'' неотрицательна.
Требуется найти [[совершенное паросочетание|совершенное]], или [[совершенное паросочетание|полное]] [[паросочетание]] c наименьшей стоимостью.

Будем называть функцию <math>y\colon (S \cup T) \to \mathbb{R}</math> '''потенциалом''', если <math>y(i)+y(j) \leq c(i,j)</math> для каждых <math>i \in S, j \in T</math>.
'''Значение потенциала''' определяется как <math>y=\sum_{v\in S\cup T} y(v)</math>.
Нетрудно заметить, что стоимость любого совершенного [[паросочетание|паросочетания]] не меньше, чем значение любого потенциала.
Венгерский метод находит полное паросочетание и потенциал с одинаковой стоимостью/значением, что доказывает оптимальность обеих величин.
Фактически он находит совершенное паросочетание '''жёстких''' рёбер: ребро <math>ij</math> называется жёстким для потенциала <math>y</math>, если <math>y(i)+y(j) = c(i, j)</math>.
Подграф жёстких рёбер будем обозначать как <math>\mathbf{G_y}</math>.
Стоимость полного паросочетания в <math>\mathbf{G_y}</math> (если оно существует) равна значению <math>y</math>.

== Алгоритм в терминах двудольных графов ==

Алгоритм хранит в памяти потенциал <math>y\ </math> и ориентацию (задание направления) каждого жёсткого ребра, обладающую тем свойством, что рёбра, направленные от <math>T\ </math> к <math>S\ </math> образуют паросочетание, которое мы обозначим <math>M</math>.
Ориентированный граф, состоящий из жёстких рёбер с заданной ориентацией, мы обозначаем <math>\mathbf{\overrightarrow{G}_y}</math>.
Таким образом, в любой момент есть три типа рёбер:
* нежёсткие (и не принадлежащие <math>M\ </math>)
* жёсткие, но не принадлежащие <math>M\ </math>
* жёсткие и принадлежащие <math>M\ </math>

Изначально <math>y\ </math> везде равно 0, и все рёбра направлены от <math>S\ </math> к <math>T\ </math> (таким образом, <math>M\ </math> пусто).
На каждом шаге или модифицируется <math>y\ </math> так, что увеличивается множество вершин <math>Z\ </math>, определённое в следующем абзаце, или изменяется ориентация, чтобы получить паросочетание с большим числом рёбер;
при этом всегда остаётся верным, что все рёбра из <math>M\ </math> являются жёсткими.
Процесс заканчивается, если <math>M\ </math> — совершенное паросочетание.

Пусть на каждом шаге <math>R_S \subseteq S</math> и <math>R_T \subseteq T</math> составляют множество вершин, не инцидентных рёбрам из <math>M\ </math> (то есть <math>R_S\ </math> — множество вершин из <math>S</math>, в которые не входит ни одно ребро, а <math>R_T\ </math> — множество вершин из <math>T</math>, из которых не исходит ни одно ребро).
Обозначим через <math>Z\ </math> множество вершин, достижимых из <math>R_S\ </math> в <math>\mathbf{\overrightarrow{G}_y}</math> (оно может быть найдено [[Поиск в ширину|поиском в ширину]]).

Если <math>R_T \cap Z</math> не является пустым, это значит, что есть хотя бы один путь в <math>\mathbf{\overrightarrow{G}_y}</math> из <math>R_S\ </math> в <math>R_T\ </math>. Выбираем любой из таких путей, и изменяем ориентацию всех его ребёр на обратную. Размер паросочетания увеличится на 1. <blockquote>Для доказательства отметим два очевидных факта:
* На выбранном пути рёбра из <math>S\ </math> в <math>T\ </math> чередуются с рёбрами из <math>T\ </math> в <math>S\ </math>. Это следует из двудольности графа.
* Первая вершина пути принадлежит <math>S\ </math>, а последняя — <math>T\ </math>. Следовательно, первое и последнее его рёбра направлены из <math>S\ </math> в <math>T\ </math>.
По определению <math>\mathbf{\overrightarrow{G}_y}</math>, отсюда следует, что на выбранном пути рёбра, принадлежащие и не принадлежащие <math>M\ </math> чередуются, причём первое и последнее рёбра не принадлежат <math>M\ </math>, то есть путь является повышающим, откуда и следует доказываемое утверждение.
</blockquote>

Если <math>R_T \cap Z</math> пусто, положим <math>\Delta := \min \{c(i,j)-y(i)-y(j): i \in Z \cap S, j \in T \setminus Z\}</math>. <math>\Delta</math> положительна, потому что нет жёстких рёбер между <math>Z \cap S</math> и <math>T \setminus Z</math>. <blockquote>В самом деле, пускай такое ребро (i, j) есть. Поскольку <math>i \in Z</math>, но <math> j \notin Z</math>, вершина <math>i\ </math> достижима из <math>R_S\ </math> в <math>\mathbf{\overrightarrow{G}_y}</math>, а вершина <math>j\ </math> недостижима.
Следовательно, <math>\mathbf{\overrightarrow{G}_y}</math> не может содержать ребра (i, j).
Следовательно, <math>(i, j) \in M</math>, откуда <math>i \notin R_S</math>.
Поскольку <math>i\ </math> достижима из <math>R_S\ </math> в <math>\mathbf{\overrightarrow{G}_y}</math>, существует путь в <math>i\ </math> из какой-то вершины, принадлежащей <math>R_S\ </math>.
Рассмотрим последнее ребро этого пути. Обозначим его (k, i).
Поскольку <math>k\ </math> достижима из <math>R_S\ </math> в <math>\mathbf{\overrightarrow{G}_y}</math>, а <math>j\ </math> недостижима, <math>k\neq j</math>.
Поскольку <math>(k, i)\in \mathbf{\overrightarrow{G}_y}</math>, <math>(i, k)\in M</math>.
Следовательно, <math>i\ </math> инцидентна сразу двум рёбрам из <math>M\ </math>: <math>(i,j)\ </math> и <math>(i,k)\ </math>, что невозможно, так как <math>M\ </math> — паросочетание.
Противоречие.
</blockquote>

Увеличим <math>y\ </math> на <math>\Delta</math> на вершинах из <math>Z \cap S</math> и уменьшим <math>y\ </math> на <math>\Delta</math> на вершинах, входящих в <math>Z \cap T</math>. Новый <math>y\ </math> остаётся потенциалом. <blockquote>В самом деле, для любого ребра (i, j), <math>i \in S</math>, <math>j \in T</math>:
* если <math>i\notin Z</math>, <math>j\notin Z</math>, то c(i, j)-y(i)-y(j) не меняется, потому что не меняются ни y(i), ни y(j)
* если <math>i\in Z</math>, <math>j\in Z</math>, то c(i, j)-y(i)-y(j) не меняется, потому что y(i) увеличивается на <math>\Delta</math>, а y(j) на столько же уменьшается
* если <math>i\notin Z</math>, <math>j\in Z</math>, разность c(i, j)-y(i)-y(j) увеличивается на <math>\Delta</math>, следовательно, остаётся неотрицательной
* если <math>i\in Z</math>, <math>j\notin Z</math>, разность c(i, j)-y(i)-y(j) уменьшается на <math>\Delta</math>, но всё равно остаётся неотрицательной, потому что <math>\Delta</math> — наименьшая из таких разностей.
</blockquote>

Граф <math>\mathbf{\overrightarrow{G}_y}</math> меняется, но, несмотря на это, содержит <math>M\ </math>.
<blockquote>В самом деле, чтобы исключить из <math>\mathbf{\overrightarrow{G}_y}</math> некое ребро (i, j), <math>i \in S</math>, <math>j \in T</math>, надо сделать его нежёстким, то есть повысить разность c(i, j)-y(i)-y(j).
Как мы видели, разность повышается только если <math>i\notin Z</math>, <math>j\in Z</math>, иными словами, <math>i</math> недостижима из <math>R_S</math>, а <math>j</math> достижима. Но в таком случае ребро (j, i) не может принадлежать <math>\mathbf{\overrightarrow{G}_y}</math>, следовательно, ребро не принадлежит <math>M</math>. </blockquote>

Ориентируем новые рёбра от <math>S\ </math> к <math>T\ </math>. По определению <math>\Delta</math>, множество <math>Z\ </math> вершин, достижимых из <math>R_S</math>, увеличится (при этом число жёстких рёбер вовсе не обязательно возрастёт).
<blockquote>Для доказательства этого утвержедения сначала докажем, что ни одна вершина не пропадёт из Z. Пусть <math>V \in Z</math>. Тогда существует путь из некоей вершины, принадлежащей <math>R_S</math>, в V. Все вершины на этом пути достижимы из <math>R_S</math>, то есть принадлежат Z. Каждое рёбро на этом пути инцидентно двум вершинам из Z. Как мы видели выше, для таких рёбер разность c(i, j)-y(i)-y(j) не меняется. Значит, все рёбра пути останутся жёсткими, и V по-прежнему будет достижима из <math>R_S</math>. Теперь докажем, что хотя бы одна вершина добавится к Z. Рассмотрим ребро, на котором достигается минимум <math>\min \{c(i,j)-y(i)-y(j): i \in Z \cap S, j \in T \setminus Z\}</math>. Для этого ребра, разность c(i, j)-y(i)-y(j) обнулится, следовательно, оно станет жёстким и будет направлено из S в T, то есть от i к j.
Поскольку <math>i\in Z</math>, j также станет достижимым из <math>R_S</math>, то есть добавится к Z.</blockquote>

Повторяем эти шаги до тех пор, пока <math>M\ </math> не станет совершенным паросочетанием; в этом случае оно даёт назначение с наименьшей стоимостью.
Время выполнения этой версии алгоритма равно <math>O(n^4)</math>: <math>M\ </math> дополняется <math>n\ </math> раз, а в стадии, когда <math>M\ </math> не меняется, может быть не более <math>n\ </math> изменений потенциала (так как <math>Z\ </math> увеличивается каждый раз).
Время, необходимое на изменение потенциала, равно <math>O(n^2)</math>.



\end{document}
